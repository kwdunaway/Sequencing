package SeqProcess;
use strict; use warnings;

###############################################################################################
# Author: Keith Dunaway & Roy Chu
# Email: kwdunaway@ucdavis.edu & rgchu@ucdavis.edu
# Date: 10-30-2012
# Module Name: SeqProcess.pm
#
# This is a module with sequencing processing commands.
#
# Subroutines: 1)
#
################################################################################################

###########################################################################
#                        Header and Path Modifier                         #
###########################################################################

sub add_path 
{
	my ($addtoPATH) = @_;

	`#!/bin/bash\n\n`;
	`PATH=\$PATH:$addtoPATH\n`;
	`export PATH\n\n`;
}

###########################################################################
#                 Combine and Filter Zipped Files                         #
#  Input: Raw file folder (only zipped files and the extension is .fq.gz) #
# Output: Filtered and Combined into one .fq file                         #
###########################################################################

sub filter_zip 
{
	my ($rawfqfolder) = @_;
	my $filtered_fastq = $rawfqfolder . "filtered.fq";

	`gunzip -c $rawfqfolder*.gz | grep -A 3 '^@.* [^:]*:N:[^:]*:' |   grep -v \"^--\$\" >  $filtered_fastq\n\n`;

	return $filtered_fastq;
}
	
###########################################################################
#                               Run Bowtie                                #
#  Input: 1) Experiment Top Folder path                                   #
#         2) Bowtie output prefix                                         #
#         3) MM9 Path                                                     #
#         4) Filtered Fastq File                                          #
#                                                                         #
# Output: 1) Non-aligned Reads File                                       #
#         2) Aligned Preseparation File                                   #
###########################################################################

sub run_bowtie 
{
	my ($ExperimentTopDir, $BowtiePrefix, $mm9path, $filtered_fastq) = @_;
	
	`mkdir $ExperimentTopDir\n`;

	my $nonalignedreadsfile = $ExperimentTopDir . $BowtiePrefix . "_NonAligned.fq";
	my $alignedpreseparationfile = $ExperimentTopDir . $BowtiePrefix . "_alignedpreseparation.txt";

	`bowtie -p 4 -M 1 -k 1 --chunkmbs 256 --strata --best --un $nonalignedreadsfile $mm9path $filtered_fastq $alignedpreseparationfile\n\n`;

	return ($nonalignedreadsfile, $alignedpreseparationfile);
}

###########################################################################
#                     Separate Repeats from Uniques                       #
#  Input: 1) Experiment Top Folder path                                   #
#         2) Bowtie output prefix                                         #
#         3) Aligned Preseparation File                                   #
#                                                                         #
# Output: 1) Unique Aligned Reads File                                    #
#         2) Repetitive Aligned Reads File                                #
###########################################################################

sub separate_repeats 
{
	my ($ExperimentTopDir, $BowtiePrefix, $alignedpreseparationfile) = @_;

	my $uniqalignedreadsfile = $ExperimentTopDir . $BowtiePrefix . "_Uniq.txt";
	my $repalignedreadsfile = $ExperimentTopDir . $BowtiePrefix . "_Repeat.txt";

	open(IN, "<$alignedpreseparationfile") or die "cannot open $alignedpreseparationfile infile";
	open(UNIQOUT, ">$uniqalignedreadsfile") or die "cannot open $uniqalignedreadsfile outfile";
	open(REPOUT, ">$repalignedreadsfile") or die "cannot open $repalignedreadsfile outfile";

	while (<IN>) 
	{
		chomp;
		my @line = split ("\t", $_);
		if($line[6] > 0) 
		{
			print REPOUT $_, "\n";
		}
		else 
		{
			print UNIQOUT $_, "\n";
		}
	}


	close IN;
	close UNIQOUT;
	close REPOUT;

	return ($uniqalignedreadsfile, $repalignedreadsfile);
}

###########################################################################
#                     Eland Extended Format to BED                        #
#                                                                         #
#  This subroutine takes sequences in Eland Extended format (also known   #
#  as s_#_export.txt files) and produces multiple BED files which can     #
#  be used to analyze the data.                                           #
#                                                                         #
#  Input: 1) Input file name                                              #
#         2) Output file name                                             #
#         3) Read length                                                  #
#         4) Chromosome array number                                      #
#         5) Position array number                                        #
#         6) Strand array number                                          #
#                                                                         #
# Output: Creates directory containing:                                   #
#           1) BED files for each chromosome                              #
#           2) Statistics on all reads                                    #
#           3) Gzipped non-unique and non-mappable reads files            #
#           4) Unknown reads file                                         #
###########################################################################

sub elandext_to_bed 
{
	# Input
	my ($infile, $outfile, $readlength, $chr, $pos, $strand) = @_;

	# Makes Output Directory
	if (! -d $outfile) 
	{ 
		`mkdir $outfile`; #creates dir if one doesn't exist
		if (! -d $outfile) { die "directory ($outfile) does not exist"} 
	}

	##################################################
	#     Global Variables and I/O Initiation        #
	##################################################

	open(IN, "<$infile") or die "cannot open $infile infile"; #opens input file to be read

	my @array; # Contains the data to be parsed
	my $QCcount = 0; # Low Quality Reads (placed in non-mappable reads)
	my $NMcount = 0; # Non-mappable Reads
	my $NonUniqcount = 0; # Non-unique Reads
	my $Unknowncount = 0; # Unknown Reads
	my @ChrMapcount; # Unique Mapped Reads by Chromosome
	for (my $n = 0; $n < 27; $n++)
	{
		$ChrMapcount[$n] = 0;
	}
	my $totalcount = 0; #Total Mapped Reads
	my $filename; # Outfile for each chromosome in bed
	my @chr_out; # Holds all the output files
	my $commandinput; # Holds Command Line Inputs

	# Hash made to include X, Y, and M
	my %chromosomes = (); # Contains chromosomes(keys = call number, values = chromosome number)

	for(my $n = 1; $n < 24; $n++)
	{
		$chromosomes{$n} = $n;
	}
	$chromosomes{24} = "X";
	$chromosomes{25} = "Y";
	$chromosomes{26} = "M";

	############################################################################
	#       Creates BED file for each Chromosome, Puts Output files in array   #
	#                                                                          #
	#   Chromosome 1 corresponds to $chr_out[0], Chr2 -> $chr_out[1], etc.     #
	#                    ChrX = [23], ChrY = [24], ChrMitochondria = [25]      #
	#   *Fastq Files* -> Non-mappable = [26], Non-unique = [27]                #
	#   *Text Files*  -> Stats = [28], Unknown = [29]                          #
	############################################################################

	for(my $n = 0; $n < 30; $n++)
	{
		if($n > 22)
		{
			if($n == 23)
			{
				$filename = $outfile . "/" . $outfile . "_chrX.bed";
			}
			if($n == 24)
			{
				$filename = $outfile . "/" . $outfile . "_chrY.bed";
			}
			if($n == 25)
			{
				$filename = $outfile . "/" . $outfile . "_chrM.bed";
			}
			if($n == 26)
			{
				$filename = $outfile . "/" . $outfile . "_NM.fq"; 
			}
			if($n == 27)
			{
				$filename = $outfile . "/" . $outfile . "_NonUnique.fq";
			}
			if($n == 28)
			{
				$filename = $outfile . "/" . "Stats_" . $outfile . ".txt";
			}
			if($n == 29)
			{
				$filename = $outfile . "/" . "Unknown_" . $outfile . ".txt";
			}
		}
		else
		{
			$filename = $outfile . "/" . $outfile . "_chr" . ($n + 1) . ".bed";
		}
		open($chr_out[$n], ">$filename") or die "cannot open $filename outfile";
	}


	############################################################################
	#           Processing data into each chromosome output file               #
	############################################################################

	while (<IN>)
	{
		chomp;
		@array = split("\t", $_); # Splitting data into array
		$totalcount++; # Total mapped reads
		# Non-mappable reads
		if ($array[$chr] eq "QC") # Low quality reads (placed in non-mappable reads)
		{ 
			$chr_out[26]->print("$_" , "\n"); 
			$QCcount++;
		}
		elsif ($array[$chr] eq "NM") # Non-mappable reads
		{ 	
			$chr_out[26]->print("$_" , "\n");  
			$NMcount++;
		}
		# Non-unique reads
		elsif ($array[6] > 0)
		{ 	
			$chr_out[27]->print("$_" , "\n"); 
			$NonUniqcount++;
		}
		# Processing unique reads to chromosomes
		elsif($array[$chr] =~ m/chr/)
		{
			foreach my $chromosome(keys %chromosomes) # Check all chromosomes
			{	
				my $chr_value = $chromosomes{$chromosome};
				if($array[$chr] =~ m/(chr$chr_value)$/)
				{ 	
					$chr_out[$chromosome-1]->print("chr", $chr_value, "\t" , 
								$array[$pos] , "\t" , 
								$array[$pos]+$readlength, 									"\t", $outfile , "\t", "0", "\t" , 
								$array[$strand] , "\n");
					$ChrMapcount[$chromosome]++;
				}
			}
			$ChrMapcount[0]++; # Add to total number of uniquely mapped reads
		}
		else # Unknown data
		{
			$chr_out[29]->print("$_\n");
			$Unknowncount = $Unknowncount + 1;
  		}
	}

	############################################################################
	#                  Printing statistics to Stats Outfile                    #
	############################################################################

	my $weirdcount = $totalcount - $QCcount - $NMcount - $NonUniqcount - $ChrMapcount[0];

	for (my $n = 1; $n < 24; $n++)
	{
		if ($ChrMapcount[$n] > 0)
		{
			$chr_out[28]->print("Number of reads mapped to Chromosome $n is:\t" , 
								$ChrMapcount[$n], "\n");
		}
	}
	$chr_out[28]->print("Number of reads mapped to Chromosome X is:\t", $ChrMapcount[24], "\n");
	$chr_out[28]->print("Number of reads mapped to Chromosome Y is:\t", $ChrMapcount[25], "\n");
	$chr_out[28]->print("Number of reads mapped to Mitochondria is:\t", $ChrMapcount[26], "\n\n");
	$chr_out[28]->print("Number of Uniquely mapped reads is:\t", $ChrMapcount[0], "\n");
	$chr_out[28]->print("Number of NonUniquely mapped reads is:\t", $NonUniqcount, "\n");
	$chr_out[28]->print("Number of QC (Low Quality reads) is:\t", $QCcount, "\n");
	$chr_out[28]->print("Number of NM (nonmappable reads) is:\t", $NMcount, "\n");
	$chr_out[28]->print("Number of unknown results (printed in separate file) is:\t", 
								$Unknowncount, "\n");
	$chr_out[28]->print("Number of weird reads (should be same as previous line) is:\t", 
								$weirdcount, "\n");
	$chr_out[28]->print("Number of Total mapped reads is:\t", $totalcount, "\n");

	############################################################################
	#      Closing Files and Gzip Non-mappable and Non-unique Reads Files      #
	############################################################################

	# Closing files
	for(my $n = 0; $n < 30; $n++)
	{
		close($chr_out[$n]);
	}
	close(IN);

	# Gzip Non-mappable and non-unique reads outfiles
	$commandinput = "gzip " . $outfile . "/" . $outfile . "_NM.fq";
	`$commandinput`;
	$commandinput = "gzip " . $outfile . "/" . $outfile . "_NonUnique.fq";
	`$commandinput`;

	############################################################################
	#                            Sort All Bed Files                            #
        #                     *Uses Sort Bed File subroutine*                      #
	############################################################################

	my $bedfile;

	foreach my $chromosome(keys %chromosomes) # Check all chromosomes
	{
		my $chr_value = $chromosomes{$chromosome};
		$bedfile = $outfile . "/" . $outfile . "_chr" . $chr_value . ".bed";
		if ($ChrMapcount[$chromosome] == 0) # Check if empty
		{
			`rm $bedfile`; # Delete if empty

		}
		else
		{
			sort_bed($bedfile);
		}
	}
}

###########################################################################
#                               Sort BED File                             #
#  Input: Unsorted BED file                                               #
# Output: Sorted BED file                                                 #
###########################################################################

sub sort_bed
{
	my ($bedfile) = @_;
	my $temp = $bedfile . "_sorted.bed";
	`sort -n +1 -2 $bedfile > $temp`;
	`rm $bedfile`;
	`mv $temp $bedfile`;
}

########################################################################################
#                     Extend Read Length of BED Files                                  #
# Takes a folder of bed files and creates a new one with read length                   #
# extended directionally based on arguments input on command line.                     #
#                                                                                      #
#  Input: 1) Input Bed File prefix (ex: DY_Chr)                                        #
#         2) Output Bed prefix without Chr (ex: NewDY will make NewDY_Chr*.bed files)  #
#         3) Read Length extension (ex: 97)                                            #
#                                                                                      #
# Output: Extended Read Length BED Files                                               #
########################################################################################

sub extend_bed_read_length
{
	my ($inputbedprefix, $outputbedprefix, $readlengthextension) = @_;

	my @Chr;             # array that contains all the the names of the mouse chromosomes
	for (my $n = 1; $n< 20; $n++)
	{
		push(@Chr, $n);
	}
	push(@Chr, "M");
	push(@Chr, "X");
	push(@Chr, "Y");

	while(@Chr)
	{
		my $chr = shift(@Chr);
		my $inputfile = $inputbedprefix . $chr . ".bed";
		open(IN, "<$inputfile") or die "cannot open $inputfile infile";
		my $outfile = $outputbedprefix . "_Chr" . $chr . ".bed";
		open(OUT, ">$outfile") or die "cannot open $outfile outfile";

		print "Processing $inputfile \n";

		while(<IN>)
		{
			chomp;
    			my @line = split ("\t", $_);
			my $start = $line[1];
			my $end = $line[2];
			if($line[5] eq "+")
			{
				my $end = $line[2]+$readlengthextension;
				print OUT $line[0],"\t",$line[1],"\t",$end,"\t",$line[3],"\t",
					$line[4],"\t",$line[5],"\n";
			}
			elsif($line[5] eq "-")
			{
				my $start = $line[1]-$readlengthextension;
				print OUT $line[0],"\t",$start,"\t",$line[2],"\t",$line[3],"\t",
					$line[4],"\t",$line[5],"\n";
			}
			else {die "$line[5] does not equal + or - \n";}
		}

		close(IN);
		close(OUT);
	}
}

########################################################################################
#                     Change Read Length of BED Files                                  #
# Takes a folder of bed files and creates a new one with read length based on          #
# arguments input on command line (This is a version of extend_bed_read_length).       #
#                                                                                      #
#  Input: 1) Input Bed File prefix (ex: DY_Chr)                                        #
#         2) Output Bed prefix without Chr (ex: NewDY will make NewDY_Chr*.bed files)  #
#         3) New Read Length (ex: 97)                                                  #
#                                                                                      #
# Output: New Read Length BED Files                                                    #
########################################################################################

sub bed_read_length
{
	my ($inputbedprefix, $outputbedprefix, $readlengthextension) = @_;

	my @Chr;             # array that contains all the the names of the mouse chromosomes
	for (my $n = 1; $n< 20; $n++)
	{
		push(@Chr, $n);
	}
	push(@Chr, "M");
	push(@Chr, "X");
	push(@Chr, "Y");

	while(@Chr)
	{
		my $chr = shift(@Chr);
		my $inputfile = $inputbedprefix . $chr . ".bed";
		open(IN, "<$inputfile") or die "cannot open $inputfile infile";
		my $outfile = $outputbedprefix . "_Chr" . $chr . ".bed";
		open(OUT, ">$outfile") or die "cannot open $outfile outfile";

		print "Processing $inputfile \n";

		while(<IN>)
		{
			chomp;
    			my @line = split ("\t", $_);
			my $start = $line[1];
			my $end = $line[2];
			if($line[5] eq "+")
			{
				my $end = $line[1]+$readlengthextension;
				print OUT $line[0],"\t",$line[1],"\t",$end,"\t",$line[3],"\t",
					$line[4],"\t",$line[5],"\n";
			}
			elsif($line[5] eq "-")
			{
				my $start = $line[2]-$readlengthextension;
				print OUT $line[0],"\t",$start,"\t",$line[2],"\t",$line[3],"\t",
					$line[4],"\t",$line[5],"\n";
			}
			else {die "$line[5] does not equal + or - \n";}
		}

		close(IN);
		close(OUT);
	}
}

###########################################################################
#                     BED Directory to VarStep WIG                        #
# Converts a directory of BED files to a directory of WIG files           #
#                                                                         #
#  Input: 1) Input BED File prefix (ex: DY_Chr)                           #
#         2) Output WIG prefix                                            #
#         3) WIG Name Prefix (for genome browser)                         #
#         4) WIG Track Color (Format: RRR,GGG,BBB)                        #
#                                                                         #
# Output: Directory of .wig Files                                         #
###########################################################################

sub beddir_to_vswig
{
	# Input
	my ($infileroot, $outfileroot, $wignameroot, $color) = @_;

	##################################################
	#     Global Variables and I/O Initiation        #
	##################################################

	my @Chr;	# array that contains all the the names of the chromosomes

	for (my $n = 1; $n < 20; $n++)
	{
		push(@Chr, $n);
	}
	push(@Chr, "M");
	push(@Chr, "X");
	push(@Chr, "Y");

	####################################################################################
	# Grabs the information from each line and assigns it to the appropriate variables #
	####################################################################################

	print "\n\nStarting Bed to Wig conversion of files with prefix $infileroot:\n";
	while(@Chr)
	{
		my $infile = $infileroot . $Chr[0] . ".bed";
		open(IN, "<$infile") or die "cannot open $infile infile"; #opens input file to be 											read (must be .bed)
		my @infileroot = split(".bed",$infile);
		my $outfile = $outfileroot . "_Chr" . $Chr[0] . ".wig";
		open(OUT, ">$outfile") or die "cannot open $outfile outfile"; #opens output file to 											write to (.wig)
		# Prints the head of the track (necessary for genome browser to read file properly) 			(customizable through terminal)
		my $wigname = $wignameroot . "_Chr" . $Chr[0];
		print OUT "track type=wiggle_0 visibility=full autoScale=off name=\"", 
			$wigname, "\" description=\"", $wigname, "\" color=", $color, "\n";

		my %PosVal;              # hash that contains the peak heights, kept small
		my $position = 0;        # position of window
		my $chromcheck;          # variable that checks each chromosome to make sure they 							are the same chromosome
		my @line;                # temp array used to retreive the information of each line
		my $chrom;               # chromosome of current line
		my $startread = 0;       # start of read at current line
		my $endread = 0;         # end of read at current line 						(does not include this position)

		while (<IN>)
		{
			chomp;
			@line = split ("\t", $_);
			$chrom = $line[0];	# makes $chrom have the chromosome information
			$startread = $line[1];	# sets the value for the start of the read to 							$startread
			$endread = $line[2];	# sets the value for the end of the read to $endread

	    		# Makes the program run faster by skipping the first gap
			if ($startread > -1)  # gets rid of all lines before 0 point
			{
				#    print "$chrom \t $startread \t $endread \n";
				if ($position == 0)
		    		{ 
					$position = $startread;	
					$chromcheck = $chrom;
					print OUT "variableStep chrom=", $chrom," step=1\n";
				}
	    
				# ends program if you have different chromosomes in your data
				die "You have different chromosomes in this bed file (Program ended before completion)/n" unless $chrom == $chromcheck;
	    
				# adds height to PosVal for the sequence found
				my $addcount = $startread;
				while ($addcount < $endread)
				{
					if (exists $PosVal{$addcount})
					{
						$PosVal{$addcount} = $PosVal{$addcount} + 1;
						# print "$PosVal{$addcount} \n";
					}
					else
					{
						$PosVal{$addcount} = 1;
					}
					# print "$addcount \t",$PosVal{$addcount}, "\n";
					$addcount = $addcount +1;
				}

	##################################################
	# Prints data to a fixed step wiggle file (.wig) #
	##################################################

	# Since you should NEVER have a read's start before the current read's start, 
	# this will print all positions until that point

				while ($position < $startread) 
				{
					if (exists $PosVal{$position})
					{
						print OUT $position, "\t", $PosVal{$position}, "\n";
						delete $PosVal{$position};
						$position = $position + 1;
					}
					else # skips gaps by jumping to the next position and 							starting a new fixed step line
					{
		    				$position = $startread;
					}
				}
			}
		}

	##############################################################
	# Prints data past the window to $outfile (ONE LAST TIME!!!) #
	##############################################################

	#  This will print the rest of the reads
		while ($position < $endread) 
		{
			if (exists $PosVal{$position})
			{
				print OUT $position, "\t", $PosVal{$position}, "\n";
				delete $PosVal{$position};
				$position = $position + 1;
			}
		}
    
		close IN;
		close OUT;
		print "Finished with Chromosome $Chr[0] \n";
		shift(@Chr);
	}

}
# WIG to FPKMWIG
# Vis FPKMWIG



1;

